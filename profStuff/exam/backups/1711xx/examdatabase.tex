\documentclass{exam}
\begin{document}
FIRST QUIZ: CS4472A Tuesday, 3 October 2017, 7:10pm, Room MC17\newline
\newline
\newline
\newline
NAME AS APPEARS ON STUDENT ID:\newline
\newline
STUDENT ID NUMBER:\newline
\newline
UWO/CONFLUENCE USER NAME:\newline
\newline
REMINDERS:
\begin{enumerate}
\item (from course outline) The quiz will be closed book, closed notes, with no electronic devices allowed, with particular reference to any electronic devices that are capable of communication and/or storing information.
\item Write neatly.  If the marker can't read it, it is wrong.
\item This exam shouldn't take long to write.  On the other hand, time will pass.  It is a 30 minute quiz with 20 questions.  If you complete a question every  minute you will still have 10 minutes at the end to double check that everything is in order.
\item While you are not allowed to open the exam booklet until the proctor says you can, you can fill out the information on the cover page.  You should also get out your student id and make sure your pencils and pens are in order.  If you need to get something out of your jacket or knapsack once the exam has started, raise your hand and wait til a proctor comes to you to oversee the matter.
\end{enumerate}
\newpage
\begin{enumerate}
\item To illustrate the relation between testing and software design, we will look at the programming technique ANSWER
\begin{itemize}
\item test driven development
\end{itemize}
\item An important concept we will look at related to the question of when has one done enough testing is ANSWER
\begin{itemize}
\item coverage
\item mutation
\end{itemize}
\item It is easy to make up test inputs, but it can be tricky to know what the right output for a given input should be.  This is refered to as the ANSWER problem
\begin{itemize}
\item Oracle
\end{itemize}
\item Testing is generally about finding errors that have already been made.  This course also covers the topic of ANSWER, which is about trying to prevent errors from being made in the first place.
\begin{itemize}
\item quality assurance
\end{itemize}
\item The first testing framework for Ruby that we are looking at is called ANSWER
\begin{itemize}
\item minitest
\end{itemize}
\item The first tool for checking code quality for programs written in Ruby is ANSWER, which is described as a code smell detector.
\begin{itemize}
\item reek
\end{itemize}
\item The number of quizzes CS4472 will have this semester is ANSWER
\begin{itemize}
\item 3
\end{itemize}
\item The number of weekly practices that CS4472 will have this semester is ANSWER
\begin{itemize}
\item 10
\end{itemize}
\item The number of practice reviews that CS4472 will have this semester is ANSWER
\begin{itemize}
\item 4
\end{itemize}
\item The per cent of the total mark allocated for all the quizzes is ANSWER
\begin{itemize}
\item 21
\end{itemize}
\item The per cent of the total mark allocated for all the weekly practices is ANSWER
\begin{itemize}
\item 30
\end{itemize}
\item The per cent of the total mark allocated for all the practice reviews is ANSWER
\begin{itemize}
\item 49
\end{itemize}
\item The practice technique advocated in this class is a modification of the ANSWER
\begin{itemize}
\item Personal Software Process
\end{itemize}
\item A main theme behind the practice technique advocated in this class is that in order to improve your programming, ANSWER
\begin{itemize}
\item you need data about your past programming
\end{itemize}
\item A common piece of information for people interested in programmer productivity to track is ANSWER
\begin{itemize}
\item time spent
\item number of lines of code written
\item number of defects found
\end{itemize}
\item Although we often think of programs as taking inputs and producing outputs, a higher level view of what is going on is to think of the programs as ANSWER about how to take inputs and produce outputs.
\begin{itemize}
\item encode knowledge
\end{itemize}
\item The scripts that were designed to aid the practice process assume that you will be uploading a copy of your work to BitBucket every time you ANSWER
\begin{itemize}
\item record a note about your practice progress
\end{itemize}
\item The protocols for practice expect that the longest amount of time that you will practice before recording a note is ANSWER
\begin{itemize}
\item 30 minutes
\end{itemize}
\item The total amount of practice time you can get credit for during a practice week is ANSWER
\begin{itemize}
\item 3 hours
\end{itemize}
\item The four phases of testing (according to Whittaker) are: 1) modeling the software environment, 2) selecting test cases, 3) running and checking test cases, and 4) ANSWER
\begin{itemize}
\item checking how well the testing is going
\end{itemize}
\item The testing technique called boundary value partition starts with the notion of breaking the space of inputs into ANSWER
\begin{itemize}
\item regions of interest
\end{itemize}
\item Structural testing is another name for ANSWER
\begin{itemize}
\item code-based testing
\item white-box testing
\end{itemize}
\item The kind of testing we do to make sure that when we change a program we do not break something that used to work is called ANSWER
\begin{itemize}
\item regression testing
\end{itemize}
\item Using combinatorial testing, if I have 10 binary inputs, I only need to use ANSWER test cases (each a setting of each of the 10 inputs) to expect to find 98 per cent of the errors in the program.
\begin{itemize}
\item 13
\end{itemize}
\item The ANSWER is a method developed by Watt S. Humphrey to help individuals improve their programming skills based on existing methods that had been developed to help organizations improve their product development capabilities.
\begin{itemize}
\item Personal Software Process
\end{itemize}
\item The paper Orthogonal defect classification-a concept for in-process measurements was an example of people at IBM analyzing records of defects in order to ANSWER
\begin{itemize}
\item improve their process
\end{itemize}
\item When multiple methods of a class have the same parameters, this is a code smell called ANSWER
\begin{itemize}
\item data clumping
\end{itemize}
\item When multiple methods of a class have the same parameters, that generally indicates that those parameters should ANSWER
\begin{itemize}
\item be put into a class of their own
\end{itemize}
\item MicroTest (MiniTest subset) discourages the writing of tests that depend on side-effects of the previous test by ANSWER
\begin{itemize}
\item running tests in random order
\end{itemize}
\item MicroTest (MiniTest subset)'s usage pattern is for the test class to inherit from Test so that Class.inherited can be used to ANSWER
\begin{itemize}
\item get a list of test classes
\end{itemize}
\item MicroTest (MiniTest subset) uses public\_instance\_methods to ANSWER
\begin{itemize}
\item find methods that begin test\_
\end{itemize}
\item The TDD Cycle is ANSWER
\begin{itemize}
\item Red Green Refactor
\end{itemize}
\item RSpec specifications are sometimes called ANSWER documentation
\begin{itemize}
\item executable
\end{itemize}
\item Unlike MiniTest which is implemented as a class library, RSpec is implemented in Ruby as an ANSWER
\begin{itemize}
\item domain-specific language
\item DSL
\end{itemize}
\item RSpec and Cucumber are tools designed to support the ANSWER style of software development
\begin{itemize}
\item Behavior-driven development
\item BDD
\end{itemize}
\item The differences between RSpec and Cucumber result from the intent that Cucumber test files are meant to be readable by ANSWER
\begin{itemize}
\item the customer and the programmer
\end{itemize}
\item The differences between RSpec and Cucumber result from the intent that RSpec test files are meant to be readable by ANSWER
\begin{itemize}
\item just the programmer
\end{itemize}
\item The Capability Maturity Model for US government contractors distinguishes 5 levels of company software development process.  Level 1 is characterized as ANSWER
\begin{itemize}
\item chaotic
\item ad hoc
\end{itemize}
\item The Capability Maturity Model for US government contractors distinguishes 5 levels of company software development process.  Level 5 is characterized as ANSWER
\begin{itemize}
\item continually improving
\end{itemize}
\item Many of the ideas of the Capability Maturity Model were adapted to individual developers under the name ANSWER
\begin{itemize}
\item Personal Software Process
\end{itemize}
\item In the Testing Maturity Model, at Level 5, we aim at ANSWER rather than defect detection
\begin{itemize}
\item defect prevention
\end{itemize}
\item The corporate policy of developers merging their working copies into the main line of the branch repository several times a day is called ANSWER
\begin{itemize}
\item continuous integration
\end{itemize}
\item The motivation behind multiple merges per day per developer is to ANSWER
\begin{itemize}
\item minimize merge conflicts
\end{itemize}
\item The pattern where you create an object whose job is to create other objects (rather than using new to create other objects) is called ANSWER
\begin{itemize}
\item the factory pattern
\end{itemize}
\item While the notation looks odd, in RSpec, it is actually implemented in Ruby as an ANSWER
\begin{itemize}
\item method
\end{itemize}
\item In MiniTest, we write test classes that inherit from Test, but in RSpec these test classes are actually being created at runtime by ANSWER
\begin{itemize}
\item describe
\end{itemize}
\item Once RSpec has created a test class, it fills in its definition by executing the Ruby method ANSWER
\begin{itemize}
\item module\_exec
\end{itemize}
\item When I say that in RSpec, expect x.to eq y, eq an object that inherits from ANSWER, meeting the requirements of to
\begin{itemize}
\item Matcher
\end{itemize}
\item Modified condition/decision coverage is often a requirement (regulatory or contractual) in ANSWER
\begin{itemize}
\item safety-critical applications
\item avonic systems
\item automotive systems
\end{itemize}
\item The four requirements of MC/DC are: 1) each entry and exit point is invoked, 2) each decision takes every possible outcome, 3) each condition in a decision takes every possible outcome, and 4) ANSWER
\begin{itemize}
\item each condition in a decision is shown to independently affect the outcome of a decision
\end{itemize}
\item One study of 198 user major failure reports on 5 widely used distributed systems found statement coverage testing could have caught nearly ANSWER of the causes.
\begin{itemize}
\item a quarter
\item 25 per cent
\item 23 per cent
\end{itemize}
\item One study of 198 user major failure reports on 5 widely used distributed systems found that nearly all failures were caused by coding mistakes in ANSWER
\begin{itemize}
\item the error handling code
\end{itemize}
\item One study of 100 large open source Java programs compared better code coverage with number of post-release defect reports and found ANSWER
\begin{itemize}
\item no connection
\end{itemize}
\item A study by Ahmed et al found that the probability of errors in untested code was ANSWER the probability of errors in tested code
\begin{itemize}
\item twice
\end{itemize}
\item The S in Solid stands for ANSWER
\begin{itemize}
\item single responsibility principle
\end{itemize}
\item The O in SOLID stands for ANSWER
\begin{itemize}
\item open/closed principle
\end{itemize}
\item The L in SOLID stands for ANSWER
\begin{itemize}
\item Liskov substition principle
\end{itemize}
\item The I in SOLID stands for ANSWER
\begin{itemize}
\item interface segregation principle
\end{itemize}
\item The D in SOLID stands for ANSWER
\begin{itemize}
\item dependency inversion principle
\end{itemize}
\item According to Robert Martin who first promoted the SOLID methodology, the S doesn't refer to functions, but to ANSWER
\begin{itemize}
\item roles in the business that uses the software
\end{itemize}
\item According to Michael Feathers, code that is difficult to test is ANSWER
\begin{itemize}
\item poorly designed
\end{itemize}
\end{enumerate}
\end{document}
